<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, minimum-scale=1" />

      <link rel="stylesheet" href="./horizn.2.0.css">
      <link rel="stylesheet" href="./ghk.css">
      <link rel="stylesheet" href="./prettify.css">
      <link rel="stylesheet" href="./sunburst.css">
      <link rel="stylesheet" href="./site.css">
   </head>
   <body>
      <input type="checkbox" id="horizn-article-open">
      <header class="horizn">
         <nav>subscribe</nav>


         <h1>site name</h1>
         <label for="horizn-article-open"><h3>toggle</h3></label>


      </header>
      <aside class="horizn">
         <nav></nav>


         <ol>
            <li>
               <a href="#">
                  <span class="circle ">&nbsp;</span>
                  <h3>Connecting to a Local Microsoft SQL Server on MacOS with Docker and Dotnet&nbsp;Core</h3>
                  <p>
                     <time datetime="2018-03-24T00:00:00Z">2018.03.24</time>
                  </p>
                  <p></p>
                  <p>I'm a developer that uses Microsoft technology, and I'm on a mission to never use the Windows OS again <em>(haha, ok. maybe not never again)</em>...</p><p></p>
               </a>
            </li>
            <li>
               <a href="#">
                  <span class="circle circle-orange">&nbsp;</span>
               </a>
            </li>
         </ol>
         
         
      </aside>
      <article class="horizn">
         <nav>close</nav>


         <h1>Connecting to a Local Microsoft SQL Server on MacOS with Docker and Dotnet Core</h1>
         <p>Hello again, my name is Rich Minchuk, and I'd like to describe some infrastructure as code. What exactly does that mean?


            <label for="horizn-article-open"><h3></h3></label>
            <label for="horizn-article-open"><h3>toggle</h3></label>

         </p><p>Well, it means a few things.</p><ul><li>It means that I'd like to know how the systems I'm working with were created.</li><li>It means that I'd like to know how to recreate the systems I'm working with.</li><li>It means that I'd like to know that I can redeploy exactly what was lost in the case of a disaster.</li><li>It means that I'd probably like to version control this code as well.</li></ul><p>I would like a singular place that I can look that describes the infrastructure I'm working with (say I'm deploying an application to this infrastructure), and know exactly how it was created. In specific cases where I might be unsure if my infrastructure matches the code that describes it, I should be able to easily destroy the infrastructure and know exactly how  to recreate it.</p><p>Terraform is an open source tool for defining infrastructure as code. You can use it to define on-prem and cloud infrastructure (IE: VMWare, AWS, Azure, GCP, Networking, etc..), as well as provision software using well known infrastructure automation frameworks (Helm, Chef, etc..).</p><p>When we "terraform infrastructure," we are using the defined-in-code infrastructure to inform how we "plan" it's deployment using the <code class="prettyprint prettyprinted" style=""><span class="pln">terraform plan</span></code> command, then apply the diff of changes using <code class="prettyprint prettyprinted" style=""><span class="pln">terraform apply</span></code>. To define our infrastructure as code we use Hashicorp Configuration Language and JSON, and here's what that looks like. 
            </p><pre class="prettyprint prettyprinted" style=""><code class="language-js"><span class="com">// Hashicorp Configuration Language</span><span class="pln">
         </span><span class="typ">Variable</span><span class="pln"> </span><span class="str">"ami"</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
         type </span><span class="pun">=</span><span class="pln"> </span><span class="str">"string"</span><span class="pln">
         description </span><span class="pun">=</span><span class="pln"> </span><span class="str">"the ami to use"</span><span class="pln">
         </span><span class="pun">}</span><span class="pln"></span><span class="com">// Plain old JSON</span><span class="pln">
         </span><span class="pun">{</span><span class="pln"></span><span class="str">"Variable"</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="str">"ami"</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
               </span><span class="str">"description"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"the ami to use"</span><span class="pln">
            </span><span class="pun">}</span><span class="pln"></span><span class="pun">}</span><span class="pln"></span><span class="pun">}</span></code></pre><p>In the example above, I'm creating a variable I can use later in my project to define which Amazon Machine Image I want to use, and you can see the syntactical differences between Hashicorp Configuration Language and JSON as well.</p><h3>Resources &amp; Other Components</h3><p>Resources are the primary component you'll work with after setting up a terraform repo. They define the infrastructure we wish to create, according to how the resource expects the infrastructure to be defined.</p><pre class="prettyprint prettyprinted" style=""><code class="language-js"><span class="pln">resource </span><span class="str">"asw_instance"</span><span class="pln"> </span><span class="str">"web"</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
         ami </span><span class="pun">=</span><span class="pln"> </span><span class="str">"ami-a1b2c3d4"</span><span class="pln">
         instance_type </span><span class="pun">=</span><span class="pln"> </span><span class="str">"t2.micro"</span><span class="pln">
         </span><span class="pun">}</span></code></pre><p>In this example, we've specified that the "AWS Instance" called "web" is based on the Amazon Machine Image "AMI - a1 b2 c3 d4", and it's of the "instance type" "t2 micro". And for now, that's all we really need to define this <em>machine</em> in code.</p><p>A provider is a configuration block that <em>exposes</em> specific Resources.</p><pre class="prettyprint prettyprinted" style=""><code class="language-js"><span class="pln">provider </span><span class="str">"aws"</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
         region </span><span class="pun">=</span><span class="pln"> </span><span class="str">"us-east-1"</span><span class="pln">
         version </span><span class="pun">=</span><span class="pln"> </span><span class="str">"~&gt; 2.00"</span><span class="pln">
         </span><span class="pun">}</span></code></pre><p>For example, if I wanted to create a virtual machine in AWS, I would use the AWS Provider to expose the "AWS Instance" resource (above).</p><pre class="prettyprint prettyprinted" style=""><code class="language-js"><span class="pln">module </span><span class="str">"my-module-that-does-things"</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
         source </span><span class="pun">=</span><span class="pln"> </span><span class="str">"./my-module-dir"</span><span class="pln">
         my</span><span class="pun">-</span><span class="pln">input</span><span class="pun">-</span><span class="pln">variable</span><span class="pun">:</span><span class="pln"> </span><span class="lit">5</span><span class="pln">
         </span><span class="pun">}</span></code></pre><p>Modules are an abstraction layer for resources that are typically used together. They help you encapsulate complexity out of the way. From the root module (or your terraform git repository's top level folder) you can call any number of modules. So, instead of configuring a lengthy resource definition in your top level <code class="prettyprint prettyprinted" style=""><span class="pln">main</span><span class="pun">.</span><span class="pln">tf</span></code> file, abstract away it's inputs in a sub module.</p><p>Even better, there are hundreds of prebuilt modules from your to easily get started with, and they're accessible through the <a href="registry.terraform.io" target="_blank">Terraform Registry</a>. Each module in the Terraform Registry comes with examples of how to build these pieces of infrastructure inside your own terraform project.</p><p>As you saw above I included a custom variable called <code class="prettyprint prettyprinted" style=""><span class="kwd">my</span><span class="pun">-</span><span class="pln">input</span><span class="pun">-</span><span class="pln">variable</span></code> in the call to <code class="prettyprint prettyprinted" style=""><span class="kwd">my</span><span class="pun">-</span><span class="kwd">module</span><span class="pun">-</span><span class="pln">that</span><span class="pun">-</span><span class="pln">does</span><span class="pun">-</span><span class="pln">things</span></code>. Variables help you define the inputs that your project or module requires. When building infrastructure you may require environment specific configuration. Being able to substitute this information at planning and execution is a crucial component of multi-environment based infrastructure management.</p><pre class="prettyprint prettyprinted" style=""><code class="language-sh"><span class="pln">terraform plan </span><span class="pun">-</span><span class="pln">f my</span><span class="pun">-</span><span class="pln">variable</span><span class="pun">-</span><span class="pln">file</span><span class="pun">.</span><span class="pln">tf
         </span><span class="com"># or</span><span class="pln">terraform plan </span><span class="pun">-</span><span class="pln">f my</span><span class="pun">-</span><span class="pln">variable</span><span class="pun">-</span><span class="pln">file</span><span class="pun">.</span><span class="pln">tf</span><span class="pun">.</span><span class="pln">json</span></code></pre><p>We'd define this environment specific configuration in variable files, which are included when we terraform plan, or terraform apply the infrastructure.</p><p>Data sources are an interesting way to dynamically modify your terraform plan. For example, I might want to create an EC2 instance based on the latest Amazon Machine Image.</p><pre class="prettyprint prettyprinted" style=""><code class="language-js"><span class="pln">data </span><span class="str">"aws_ami"</span><span class="pln"> </span><span class="str">"web"</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
         filter </span><span class="pun">{</span><span class="pln">name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"state"</span><span class="pln">
            values </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="str">"available"</span><span class="pun">]</span><span class="pln">
         </span><span class="pun">}</span><span class="pln">most_recent </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pln">
         </span><span class="pun">}</span><span class="pln">resource </span><span class="str">"aws_instance"</span><span class="pln"> </span><span class="str">"web"</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
         ami </span><span class="pun">=</span><span class="pln"> data</span><span class="pun">.</span><span class="pln">aws_ami</span><span class="pun">.</span><span class="pln">web</span><span class="pun">.</span><span class="pln">id
         instance_type </span><span class="pun">=</span><span class="pln"> </span><span class="str">"t1.micro"</span><span class="pln">
         </span><span class="com">// ... continued below</span></code></pre><p>I can define an "AWS AMI" data source, then reference the ID of the machine image in my AWS Instance resource definition. When I terraform plan my project, It'll return whether or not there's a new Amazon Machine Image for me to use or not.</p>



      </article>
   </body>
</html>